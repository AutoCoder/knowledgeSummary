**协同过滤(**Collaborative Filtering**)**

在推荐系统中，最基本的算法就是协同过滤算法。

协同过滤算法我们可以分为三类：

- 基于用户的协同过滤算法（UserCF）

  基于用户的协同，就是说找到兴趣相同的用户，把其中某个用户选择过的东西，推荐给其他的用户

  **例子：**

  一个相亲网站，用户A看过的照片集合是$$ \{a, b, c, d \}$$ , 用户B 看过的照片集合是$$\{a, b, c, d, e, f\}$$

  那么他们喜欢异性的相似度为 $$\displaystyle \frac { \{a, b, c, d \} } { \{a, b, c, d, e, f\} } = \frac{2}{3}$$

  相似度较高，所以可以给A 推荐 $$\{e ,f\}$$

- 基于物品的协同过滤算法（ItemCF）

  找到与物品相关的另外一些物品，给使用了使用了该物品的用户推荐相关的物品，比如啤酒和尿布

  **例子：**

  一个购物网站，商品集合 $$\{a, b, c\} $$, 经常一起被购买，具有很强的相关性。

  那么可以对购买了商品$$a$$ 的用户推荐 $$\{b, c \}$$

- 基于模型的协同过滤算法

  ....

  矩阵分解

  .... (有很多，不一一列举，请参考[链接](https://www.cnblogs.com/chenliyang/p/6548306.html))



**协同过滤解决了什么问题？**

上面举出的两个例子，解决的是用户对某种未浏览过的“物品”的需求程度的问题。

假设如下矩阵的行是用户，列是商品， 矩阵中的元素为用户的购买次数或者浏览次数

$${\begin{bmatrix} 2 &2 &... &0  &4 \\ 0 &3  &...&8  &1 \\ ... &...  &...  &... &..\\ 0 &3  &0  &0 &5\\ 0 &2  &4  &5 &0\\\end{bmatrix}}$$

那么商品的数目是很多的，用户不可能购买过所有的商品，他对很多商品是没有购买过的甚至不知道的（即矩阵中的0值）

那么协同过滤其实完成了对某些0值的**填充**。



**矩阵分解**

方阵$$A_{n \times n}$$可以进行特征分解，分解成 特征向量和 特征值

非方阵$$A_{m \times n}$$ 不能进行特征分解，只能进行奇异值分解(**SVD**)，$$A=USV^T$$, 矩阵S对角线上的元素被称为矩阵A的**奇异值** 

矩阵分解可以为推荐算法，将用户和喜好的商品对应的矩阵做奇异值分解，进而得到隐含的用户需求来做推荐。



**【我的疑问】Z矩阵的矩阵分解是否能按照协同过滤的思路去理解？**

1. 上面提到的矩阵分解方法，解决的问题是填充问题，而我们的Z表是稠密的，每条路的属性都是已知的。

2.  协同过滤中行全部是user，列是商品item， 并不是这个user的属性，比如年纪，性别等。 这和我们的Z矩阵是不同的，Z矩阵中行全部是road， 列是所有road的属性， 和协同过滤矩阵分解的输入完全不同。 

   (Mr矩阵的矩阵分解是可以按照协同过滤去理解的，因为他的行是时间片，列是road，矩阵中的元素是速度和协同过滤常见的输入是一致的。)